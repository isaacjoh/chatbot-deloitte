Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.findModules = findModules;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _acorn = require('acorn');

var _acornUmd = require('acorn-umd');

var _acornUmd2 = _interopRequireDefault(_acornUmd);

var _estraverse = require('estraverse');

var _estraverse2 = _interopRequireDefault(_estraverse);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _updateReferences = require('./updateReferences');

var _updateReferences2 = _interopRequireDefault(_updateReferences);

var _Error = require('./Error');

var _Error2 = _interopRequireDefault(_Error);

var acornOptions = {
  ecmaVersion: 6,

  sourceType: 'module',

  // Be super loose (as who cares for this purpose)
  allowImportExportEverywhere: true,
  allowReturnOutsideFunction: true,
  allowHashBang: true
};

function matchesPath(valids, path) {
  return (0, _lodash.includes)(valids, path) || (0, _lodash.includes)(valids, (0, _path.normalize)(path));
}

function findModules(path, _ref) {
  var imports = _ref.imports;
  var scope = _ref.scope;

  var result = [];
  _estraverse2['default'].traverse(scope, {
    enter: function enter(node) {
      switch (node.type) {
        case 'MemberExpression':
          if ((0, _lodash.includes)(imports, node.object.name)) {
            if (node.computed) {
              var msg = 'Could not id computed function ' + node.object.name + '[' + node.property.name + ']';
              throw new _Error2['default'](msg, path);
            }
            result.push(node.property.name);
          }
          break;
        case 'CallExpression':
          {
            // Detect chaining
            var callee = node;
            var props = [];
            while (callee = callee.callee) {
              if (callee.property) {
                props.push(callee.property.name);
              }
              if (callee.object) {
                callee = callee.object;
              }
              if (!callee.callee) {
                break;
              }
            }
            if (callee && (0, _lodash.includes)(imports, callee.name)) {
              result.push.apply(result, props);
            }
            break;
          }
      }
    }
  });
  return result;
}

exports['default'] = function (code, path, options) {
  var ast = (0, _acorn.parse)(code, _lodash2['default'].assign({
    ranges: true,
    locations: true
  }, acornOptions, _lodash2['default'].result(options, 'acorn')));

  var result = [];

  var outputFile = options.output && (0, _path.relative)((0, _path.dirname)(path), options.output);

  // imports to consider lodash (e.g. lodash-compact, lodash, etc)
  var lodashOptions = (0, _lodash.compact)((0, _lodash.flatten)([options.lodash, _path.normalize, outputFile]));

  (0, _lodash2['default'])((0, _acornUmd2['default'])(ast, {
    amd: false,
    cjs: (0, _lodash.includes)(options.format, 'cjs'),
    es6: (0, _lodash.includes)(options.format, 'es6')
  })).filter(function (node) {
    // consider adding lodash-fp & others
    return matchesPath(lodashOptions, node.source.value);
  }).each(function (node) {
    // Add direct specifiers (`import {map, pick} from 'lodash'`)
    (0, _lodash2['default'])(node.specifiers).map('imported').compact().each(function (requireNode) {
      result.push(requireNode.name);
    }).value();
  }).tap(function (nodes) {
    if (options.update && nodes.length) {
      (0, _updateReferences2['default'])(code, path, nodes, options);
    }
  }).map(function (node) {
    // filter the specifiers down to the direct imports
    // (handles `import x,{y,z} from 'foo';)
    return {
      imports: (0, _lodash.reject)(node.specifiers, 'imported').map(function (x) {
        return x.local.name;
      }),
      scope: node.scope.block
    };
  }).each(function (node) {
    result.push.apply(result, _toConsumableArray(findModules(path, node)));
  }).value();

  (0, _lodash2['default'])((0, _acornUmd2['default'])(ast, {
    amd: (0, _lodash.includes)(options.format, 'amd'),
    cjs: false,
    es6: false
  })).map(function (define) {
    var imports = define.imports.filter(function (specifier) {
      return matchesPath(lodashOptions, specifier[0].value);
    });
    if (imports.length) {
      return {
        imports: imports,
        scope: define.scope,
        type: define.type
      };
    }
  }).compact().tap(function (nodes) {
    var imports = (0, _lodash.flatten)(nodes.map(function (nodes) {
      return (0, _lodash.map)(nodes.imports, 0);
    }));
    if (options.update && imports.length) {
      (0, _updateReferences2['default'])(code, path, imports, options, nodes[0].type);
    }
  }).map(function (node) {
    // filter the specifiers down to the direct imports
    // (handles `import x,{y,z} from 'foo';)
    return {
      imports: node.imports.map(function (zip) {
        return zip[1].name;
      }),
      scope: node.scope.block
    };
  }).each(function (node) {
    result.push.apply(result, _toConsumableArray(findModules(path, node)));
  }).value();

  if (typeof options.global === 'string') {
    result.push.apply(result, _toConsumableArray(findModules(path, {
      imports: [options.global],
      scope: ast
    })));
  }

  return result;
};