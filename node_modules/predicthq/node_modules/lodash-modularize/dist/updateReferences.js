Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = updateReferences;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _recast = require('recast');

var _recast2 = _interopRequireDefault(_recast);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('./fs');

var _fs2 = _interopRequireDefault(_fs);

var _Error = require('./Error');

var _Error2 = _interopRequireDefault(_Error);

var builders = _recast2['default'].types.builders;

function replaceRequire(node, output) {
  return builders.callExpression(node.callee, [builders.literal(output)]);
}

var updaters = {
  ImportDeclaration: function ImportDeclaration(path, node, output) {
    var source = builders.moduleSpecifier(output);
    var r = builders.importDeclaration(node.specifiers, source);
    path.replace(r);
  },

  AMDImport: function AMDImport(path, node, output) {
    path.replace(builders.literal(output));
  },

  CJSImport: function CJSImport(path, node, output) {
    switch (node.type) {
      case 'VariableDeclarator':
        {
          var id = node.id;
          var init = node.init;

          path.replace(builders.variableDeclarator(id, replaceRequire(init, output)));
          break;
        }
      // Annoyingly redundant
      case 'VariableDeclaration':
        {
          var _node$declarations$0 = node.declarations[0];
          var id = _node$declarations$0.id;
          var init = _node$declarations$0.init;

          path.replace(builders.variableDeclaration(node.kind, [builders.variableDeclarator(id, replaceRequire(init, output))]));
          break;
        }
      case 'AssignmentExpression':
        {
          var operator = node.operator;
          var left = node.left;
          var right = node.right;

          path.replace(builders.assignmentExpression(operator, left, replaceRequire(right, output)));
          break;
        }
      case 'Property':
        {
          path.replace(builders.property(node.kind, node.key, replaceRequire(node.value, output)));
          break;
        }
      case 'CallExpression':
        {
          path.replace(replaceRequire(node, output));
          break;
        }
      default:
        var msg = node.type + ' commonjs imports are not currently supported (file an issue)';
        throw new _Error2['default'](msg, output);
    }
  }
};

// Update the import references from the source to point at the
// new compiled file.
exports.updaters = updaters;

function updateReferences(code, source, nodes, _ref) {
  var output = _ref.output;

  output = _path2['default'].relative(_path2['default'].dirname(source), output);
  // Ensure requires work
  output = (0, _lodash.startsWith)(output, _path2['default'].normalize('../')) ? output : './' + output;

  var ast = _recast2['default'].parse(code);
  var visitors = (0, _lodash.transform)(nodes, function (memo, nodeWrapper) {
    var format = nodeWrapper.type;
    var node = nodeWrapper.reference;
    var type = node.type;

    var updater = updaters[format];
    memo['visit' + type] = function (path) {
      var node = path.value;
      var _node$loc = node.loc;

      // Find the corresponding import for this node
      var start = _node$loc.start;
      var end = _node$loc.end;
      var other = (0, _lodash.find)(nodes, {
        reference: {
          type: type, loc: { start: start, end: end }
        }
      });
      if (other) {
        updater(path, node, output);
      }
      this.traverse(path);
    };
  }, {});

  _recast2['default'].visit(ast, visitors);
  _fs2['default'].writeFile(source, _recast2['default'].print(ast).code);
}